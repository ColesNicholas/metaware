# compute range of es values
sens.range <- max(sens.res) - min(sens.res)
# delete vestigial
rm(sens.df.list, sens.res)
# Chunk 7: mult.eff
# calculate percentage of studies with multiple effect sizes
mult.eff.per <- DF.es %>%
# identify number of effect sizes for each study (id)
group_by(id.study) %>%
count() %>%
# code whether each study has more than one effect size
mutate(dep = if_else(condition = n > 1,
true = 1,
false = 0)
) %>%
# calculate proportion of studies with more than one effect size
ungroup() %>%
summarise(mult.eff = mean(dep)) %>%
# export as percentage
as.numeric() %>%
round(digits = 2) * 100
# Chunk 8: vig.dem
# identify total number of vignettes
vig.n <- read.csv(file = "admin/vig/metaware_VigCombined.csv") %>%
nrow()
# compile demographic info for the two vignette studies
# import data from first survey
vig.surv1 <-
read_csv(file = "data/metaware_SurvData_raw.csv") %>%
filter(Finished == 1) %>%
select(indiv_gend_var : ethnicity) %>%
mutate(survey = "survey_1")
vig.surv1.n = nrow(vig.surv1)
vig.surv2 <-
read_csv(file = "data/metaware_SurvData2_raw.csv") %>%
filter(Finished == 1) %>%
select(indiv_gend_var : ethnicity) %>%
mutate(survey = "survey_2")
vig.surv <- rbind(vig.surv1, vig.surv2)
rm(vig.surv1, vig.surv2)
# describe participant demographics
survey.n <- nrow(vig.surv)
survey.gend <-
vig.surv$indiv_gend_var %>%
table() %>%
prop.table() %>%
round(2) * 100
survey.eth <-
vig.surv$ethnicity %>%
table() %>%
prop.table() %>%
round(2) * 100
survey.age.m <-
mean(vig.surv$indiv_agee_var %>% as.numeric(),
na.rm = T) %>%
round(2)
survey.age.sd <-
sd(vig.surv$indiv_agee_var %>% as.numeric(),
na.rm = T) %>%
round(2)
# put demographics into table
survey.dem = list(n = survey.n,
gend = survey.gend,
ethnicity = survey.eth,
age.m = survey.age.m,
age.sd = survey.age.sd)
# remove vestigial
rm(survey.n, survey.gend,
survey.eth, survey.age.m, survey.age.sd)
# Chunk 9: vig.rel
# open reliability data
vig1.rel <- readRDS("output/vig.surv1.rel.rds")
# Chunk 11: clean.env.2
# delete vestigial
rm(mult.eff.per, sens.range)
# Chunk 12: overall
# estimate overall effect size
overall <-
rma.mv(yi = es,
V = es.var,
data = DF.es,
random = ~ 1 | id.study / id.es) %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# estimate standard deviation of effect size distribution (i.e., Tau)
# to do so, combine both sources of estimated variability in the model
tau <- sqrt(overall$sigma2[1] + overall$sigma2[2])
# estimate proportion of hypothesis-consistent and inconsistent responding
# -0.10 < d > 0.10 is the arbitrary threshold for saying it's neither consistent or inconsistent
h.c <- pnorm(q = .10,
mean = overall$b,
sd = tau,
lower.tail = F) %>%
round(digits = 2) * 100
h.i <- pnorm(q = (-.10),
mean = overall$b,
sd = tau,
lower.tail = T) %>%
round(digits = 2) * 100
# estimate lower and upper bound of effect size distribution
dist <- rnorm(n = 1000000,
mean = overall$b,
sd = tau)
dist.min <- dist %>%
min() %>%
round(digits = 2)
dist.max <- dist %>%
max() %>%
round(digits = 2)
rm(dist)
# Chunk 13: forest
# create a temporary dataset that (a) aggregates dependent effect sizes, and (b) computes 95% CI's
tmp <- DF.es %>%
# convert to an 'escalc' object so function can run
escalc(yi = es,
vi = es.var,
data = DF.es,
measure = "SMD") %>%
# delete vestigial: es is now yi; es.var is now vi
select(-c(es, es.var)) %>%
# aggregate dependencies
aggregate(x = .,
cluster = id.study,
rho = .5) %>%
# compute CI's
rowwise() %>%
mutate(se = sqrt(vi),
ub = yi + (se * 1.96),
ub = round(ub, 2),
lb = yi - (se * 1.96),
lb = round(lb, 2),
yi = round(yi, 2)) %>%
ungroup() %>%
arrange(yi, id.study)
# create a forest plot w/ distribution overlay
ggplot(data = tmp,
aes(y = rev(1: nrow(tmp)) * .05,
x = yi,
xmin = lb,
xmax = ub)) +
#hypothesis inconsistent effects
## area
geom_area(stat = "function",
fun = dnorm,
args = list(mean = overall$b,
sd = tau),
fill = "#F8766D",
alpha = .25,
xlim = c(-2, -.10)) +
# negligible effects
## area
geom_area(stat = "function",
fun = dnorm,
args = list(mean = overall$b,
sd = tau),
fill = "grey80",
alpha = .25,
xlim = c(-.10, .10)) +
# hypothesis consistent effects
## area
geom_area(stat = "function",
fun = dnorm,
args = list(mean = overall$b,
sd = tau),
fill = "#00998a",
alpha = .25,
xlim = c(.10, 2)) +
# create dotted line at d = 0
geom_vline(xintercept = 0,
color = "black",
linetype = "dotted",
alpha = .5,
size =.5)  +
# add points and error bars
geom_point(shape = "diamond",
size = 2.5,
alpha = .8,
color = "dark grey") +
geom_errorbarh(height = .005,
size = .75,
alpha = .8,
color = "dark grey") +
# add citation label
geom_text(aes(label = citation),
x = -3.15,
hjust = 0,
size = 2.5) +
# add CI label
geom_text(aes(label = paste0(yi,
" [", lb, ", ", ub, "]")),
x = 3.6,
size = 2.5,
hjust = 1) +
labs(x = expression(paste("Hedge's ", italic("g"))),
y = "density") +
# increase plotting area
scale_x_continuous(limits = c(-3.25, 3.75),
breaks = seq(from = -2, to = 2, by = 1),
expand = c(.01, .01)) +
scale_y_continuous(expand = c(.005, 0))
# Chunk 14: neg.demand
# compute number of effect sizes that were negative and significant
neg.demand.raw <- DF.es %>%
filter(ub < 0) %>%
nrow()
# compute number of *aggregated* effect sizes that were negative and significant
neg.demand.agg <- tmp %>%
filter(ub < 0) %>%
nrow()
rm(tmp)
# Chunk 15: clean.env.99
rm(neg.demand.raw, neg.demand.agg)
# Chunk 16: mod
# create moderator analysis function
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
# conduct moderator and subgroup analyses for moderators assessed with full dataset
mod.l <- c("student", "paid", "online",
"design", "ref.r", "published",
"year", "att")
mod.r <-
sapply(X = mod.l,
simplify = F,
FUN = ModAnalysis)
rm(mod.l)
# test attention moderator in scenarios where there is a control comparison (i.e., ref.r == single)
mod.r[["awr.control"]] <-
ModAnalysis(m = "att",
df = DF.es[DF.es$ref.r == "single", ])
# test ref.type moderator in scenarios where there is a control comparison (i.e., ref.r == single)
mod.r[["ref.type"]] <-
ModAnalysis(m = "ref.type",
df = DF.es[DF.es$ref.r == "single", ])
# test all ref.type
mod.r[["ref.type.full"]] <-
ModAnalysis(m = "ref.type")
# add motivation, opportunity, belief, and prediction moderators
## Note: comparisons with nil-demand conditions are excluded
mod.r.2 <-
sapply(X = c("mot", "opp", "bel", "pre"),
simplify = F,
FUN = ModAnalysis,
df = DF.es %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
# test
ModAnalysis(m = "att * mot * opp",
df = DF.es %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
## combine results
mod.r = c(mod.r, mod.r.2)
# delete vestigial
rm(mod.r.2)
mod.r$att$mod
mod.r$mot$mod
mod.r$opp$mod
mod.r$bel$mod
DF.es %>% View()
sum(c(NA, NA), na.rm = T) = 0
sum(c(NA, NA), na.rm = T) == 0
NA - 2
tmp <- DF.es %>%
mutate(att.c = att - mean(att, na.rm = T))
tmp %>% select(att, att.chk)
tmp %>% select(att, att.c) %>% View()
tmp <- DF.es %>%
mutate(att.c = att - mean(att, na.rm = T),
mot.c = mot - mean(mot, na.rm = T),
opp.c = opp - mean(opp, na.rm = T),
att.c = att - mean(att, na.rm = T))
tmp.m.2 <- ModAnalysis(m = "att.c * mot.c * opp.c",
df = DF.es %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
tmp.m.1 <- ModAnalysis(m = "att * mot * opp",
df = tmp %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
tmp.m.2 <- ModAnalysis(m = "att.c * mot.c * opp.c",
df = tmp %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
tmp.m.2$mod
# create moderator analysis function
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t") %>%
# robust(x = .,
#        cluster = id.study,
#        clubSandwich = T)
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
# conduct moderator and subgroup analyses for moderators assessed with full dataset
mod.l <- c("student", "paid", "online",
"design", "ref.r", "published",
"year", "att")
mod.r <-
sapply(X = mod.l,
simplify = F,
FUN = ModAnalysis)
tmp.m.2 <- ModAnalysis(m = "att.c * mot.c * opp.c",
df = tmp %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t") #%>%
# robust(x = .,
#        cluster = id.study,
#        clubSandwich = T)
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
tmp.m.2 <- ModAnalysis(m = "att.c * mot.c * opp.c",
df = tmp %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
tmp.m.2$mod
# create moderator analysis function
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t") #%>%
# robust(x = .,
#        cluster = id.study,
#        clubSandwich = T)
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
# conduct moderator and subgroup analyses for moderators assessed with full dataset
mod.l <- c("student", "paid", "online",
"design", "ref.r", "published",
"year", "att")
mod.r <-
sapply(X = mod.l,
simplify = F,
FUN = ModAnalysis)
rm(mod.l)
# test attention moderator in scenarios where there is a control comparison (i.e., ref.r == single)
mod.r[["awr.control"]] <-
ModAnalysis(m = "att",
df = DF.es[DF.es$ref.r == "single", ])
# test ref.type moderator in scenarios where there is a control comparison (i.e., ref.r == single)
mod.r[["ref.type"]] <-
ModAnalysis(m = "ref.type",
df = DF.es[DF.es$ref.r == "single", ])
# test all ref.type
mod.r[["ref.type.full"]] <-
ModAnalysis(m = "ref.type")
# add motivation, opportunity, belief, and prediction moderators
## Note: comparisons with nil-demand conditions are excluded
mod.r.2 <-
sapply(X = c("mot", "opp", "bel", "pre"),
simplify = F,
FUN = ModAnalysis,
df = DF.es %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
# test
ModAnalysis(m = "att * mot * opp",
df = DF.es %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
## combine results
mod.r = c(mod.r, mod.r.2)
# delete vestigial
rm(mod.r.2)
mod.r$att$mod
mod.r$att$mot
mod.r$mot$mod
mod.r$opp$mod
mod.r$pre$mod
tmp.m.2$mod
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t") #%>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
tmp.m.2 <- ModAnalysis(m = "att.c * mot.c * opp.c",
df = tmp %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
tmp.m.2 <- ModAnalysis(m = "att.c * mot.c * opp.c",
df = tmp %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
tmp.m.2
tmp.m.2$mod
