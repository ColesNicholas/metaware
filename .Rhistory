reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(student == "yes") %>%
nrow(),
g =  mod.r$student$sub$b[[3]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$student$sub$ci.lb[[3]] %>% round(2),
", ",
mod.r$student$sub$ci.ub[[3]] %>% round(2),
"]"
),
`F` = mod.r$student$sub$zval[[3]] ^ 2 %>%
round(2),
p = mod.r$student$sub$pval[[3]] %>% as.numeric %>% apa_p()
),
## student: no
cbind(
`Moderator (bolded) and level` = "     non-students",
s = DF.es %>%
filter(student == "no") %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(student == "no") %>%
nrow(),
g =  mod.r$student$sub$b[[2]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$student$sub$ci.lb[[2]] %>% round(2),
", ",
mod.r$student$sub$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$student$sub$zval[[2]] ^ 2 %>%
round(2),
p = mod.r$student$sub$pval[[2]] %>% as.numeric %>% apa_p()
),
## student: mix
cbind(
`Moderator (bolded) and level` = "     mix",
s = DF.es %>%
filter(student == "mix") %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(student == "mix") %>%
nrow(),
g =  mod.r$student$sub$b[[1]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$student$sub$ci.lb[[1]] %>% round(2),
", ",
mod.r$student$sub$ci.ub[[1]] %>% round(2),
"]"
),
`F` = mod.r$student$sub$zval[[1]] ^ 2 %>%
round(2),
p = mod.r$student$sub$pval[[1]] %>% as.numeric %>% apa_p()
),
################
# Setting
################
cbind(
`Moderator (bolded) and level` = "Setting",
s = mod.r$online$mod$n,
k = mod.r$online$mod$k,
g =  "--",
`95% CI` = "--",
`F` = mod.r$online$mod$QM %>% round(2),
p = mod.r$online$mod$QMp %>% as.numeric %>% apa_p()
),
## online
cbind(
`Moderator (bolded) and level` = "     online",
s = DF.es %>%
filter(online == "yes") %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k =  DF.es %>%
filter(online == 'yes') %>%
nrow(),
g =  mod.r$online$sub$b[[2]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$online$sub$ci.lb[[2]] %>% round(2),
", ",
mod.r$online$sub$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$online$sub$zval[[2]] ^ 2 %>%
round(2),
p = mod.r$online$sub$pval[[2]] %>% as.numeric %>% apa_p()
),
# in person
cbind(
`Moderator (bolded) and level` = "     in-person",
s = DF.es %>%
filter(online == "no") %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(online == 'no') %>%
nrow(),
g =  mod.r$online$sub$b[[1]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$online$sub$ci.lb[[1]] %>% round(2),
", ",
mod.r$online$sub$ci.ub[[1]] %>% round(2),
"]"
),
`F` = mod.r$online$sub$zval[[1]] ^ 2 %>%
round(2),
p = mod.r$online$sub$pval[[1]] %>% as.numeric %>% apa_p()
),
################
# Payment
################
cbind(
`Moderator (bolded) and level` = "Payment",
s = mod.r$paid$mod$n,
k = mod.r$paid$mod$k,
g =  "--",
`95% CI` = "--",
`F` = mod.r$paid$mod$QM %>% round(2),
p = mod.r$paid$mod$QMp %>% as.numeric %>% apa_p()
),
## yes
cbind(
`Moderator (bolded) and level` = "     yes",
s = DF.es %>%
filter(paid == "yes") %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(paid == 'yes') %>%
nrow(),
g =  mod.r$paid$sub$b[[2]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$paid$sub$ci.lb[[2]] %>% round(2),
", ",
mod.r$paid$sub$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$paid$sub$zval[[2]] ^ 2 %>%
round(2),
p = mod.r$paid$sub$pval[[2]] %>% as.numeric %>% apa_p()
),
# no
cbind(
`Moderator (bolded) and level` = "     no",
s = DF.es %>%
filter(paid == "no") %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k =  DF.es %>%
filter(paid == 'no') %>%
nrow(),
g =  mod.r$paid$sub$b[[1]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$paid$sub$ci.lb[[1]] %>% round(2),
", ",
mod.r$paid$sub$ci.ub[[1]] %>% round(2),
"]"
),
`F` = mod.r$paid$sub$zval[[1]] ^ 2 %>%
round(2),
p = mod.r$paid$sub$pval[[1]] %>% as.numeric %>% apa_p()
),
################
# Publication status
################
cbind(
`Moderator (bolded) and level` = "Publication status",
s = mod.r$published$mod$n,
k = mod.r$published$mod$k,
g =  "--",
`95% CI` = "--",
`F` = mod.r$published$mod$QM %>% round(2),
p = mod.r$published$mod$QMp %>% as.numeric %>% apa_p()
),
## published
cbind(
`Moderator (bolded) and level` = "     published",
s = DF.es %>%
filter(published == 'yes') %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(published == 'yes') %>%
nrow(),
g =  mod.r$published$sub$b[[2]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$published$sub$ci.lb[[2]] %>% round(2),
", ",
mod.r$published$sub$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$published$sub$zval[[2]] ^ 2 %>%
round(2),
p = mod.r$published$sub$pval[[2]] %>% as.numeric %>% apa_p()
),
## unpublished
cbind(
`Moderator (bolded) and level` = "     unpublished",
s = DF.es %>%
filter(published == 'no') %>%
reframe(n.study = unique(id.study)) %>%
nrow(),
k = DF.es %>%
filter(published == 'no') %>%
nrow(),
g =  mod.r$published$sub$b[[1]] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$published$sub$ci.lb[[1]] %>% round(2),
", ",
mod.r$published$sub$ci.ub[[1]] %>% round(2),
"]"
),
`F` = mod.r$published$sub$zval[[1]] ^ 2 %>%
round(2),
p = mod.r$published$sub$pval[[1]] %>% as.numeric %>% apa_p()
)
)
apa_table(
feature.mod.table,
caption = "Study feature moderator and subgroup analyses",
note = "s = number of studies; k = number of effect size estimates; g = Hedge's g; 95% CI corresponds to the estimated value of Hedge's g; F-values represent the test of moderation in bolded rows -- and tests of the model-dervied overall effect size in non-bolded rows; The number of studies listed for a moderator analysis is not necessarily the sum of the number of studies listed for the individual levels of the moderators because many studies yielded effect sizes for multiple levels of the moderator.")
# Chunk 21: r2
# calculate a pseudo-R2
## see this page for a discussion of the method:
## https://stackoverflow.com/questions/22356450/getting-r-squared-from-a-mixed-effects-multilevel-model-in-metafor
## pairwise delete observations where we don't have information for moderator analyses
## this is to ensure that the two models we are comparing have the same observations
DF.cmplt <- DF.es %>%
filter(!is.na(student),
!is.na(ref.r),
!is.na(att))
## fit intercept-only model
m.int <- rma.mv(yi = es,
V = es.var,
data = DF.cmplt,
random = ~ 1 | id.study / id.es,
test = "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# fit moderator model and calculate r2
m.mod <- rma.mv(yi = es,
V = es.var,
data = DF.cmplt,
random = ~ 1 | id.study / id.es,
mods = ~ student + ref.r,
test = "t") %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
r2 <- (sum(m.int$sigma2) - sum(m.mod$sigma2)) / sum(m.int$sigma2)
rm(DF.cmplt, m.int, m.mod)
# Chunk 22: vig.rel.full
vig.rel <- readRDS("output/vig.survfull.rel.rds")
vig.desc <- read.csv("output/surv.sum.csv")
# Chunk 23
rbind(
# predicted demand effects
cbind(
`Moderator (bolded) and level` = "predicted demand effects",
s = mod.r$pre$mod$n,
k = mod.r$pre$mod$k,
B1 = mod.r$pre$mod$b[2] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$pre$mod$ci.lb[[2]] %>% round(2),
", ",
mod.r$pre$mod$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$pre$mod$QM %>% round(2),
p = mod.r$pre$mod$QMp %>% apa_p()
),
# understanding of study hypothesis
cbind(
`Moderator (bolded) and level` = "understanding of study hypothesis",
s = mod.r$att$mod$n,
k = mod.r$att$mod$k,
B1 = mod.r$att$mod$b[2] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$att$mod$ci.lb[[2]] %>% round(2),
", ",
mod.r$att$mod$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$att$mod$QM %>% round(2),
p = mod.r$att$mod$QMp %>% apa_p()
),
# motivation to adjust responses
cbind(
`Moderator (bolded) and level` = "motivation to adjust responses",
s = mod.r$mot$mod$n,
k = mod.r$mot$mod$k,
B1 = mod.r$mot$mod$b[2] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$mot$mod$ci.lb[[2]] %>% round(2),
", ",
mod.r$mot$mod$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$mot$mod$QM %>% round(2),
p = mod.r$mot$mod$QMp %>% apa_p()
),
# opportunity to adjust responses
cbind(
`Moderator (bolded) and level` = "opportunity to adjust responses",
s = mod.r$opp$mod$n,
k = mod.r$opp$mod$k,
B1 = mod.r$opp$mod$b[2] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$opp$mod$ci.lb[[2]] %>% round(2),
", ",
mod.r$opp$mod$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$opp$mod$QM%>% round(2),
p = mod.r$opp$mod$QMp %>% apa_p()
),
# belief in communicated hypothesis
cbind(
`Moderator (bolded) and level` = "belief in communicated hypothesis",
s = mod.r$bel$mod$n,
k = mod.r$bel$mod$k,
B1 = mod.r$bel$mod$b[2] %>% round(2),
`95% CI` =
paste0(
"[",
mod.r$bel$mod$ci.lb[[2]] %>% round(2),
", ",
mod.r$bel$mod$ci.ub[[2]] %>% round(2),
"]"
),
`F` = mod.r$bel$mod$QM %>% round(2),
p = mod.r$bel$mod$QMp %>% apa_p()
)
) %>%
apa_table(caption = "Participant rating moderator analyses",
note = "s = number of studies; k = number of effect size estimates; B1 = estimated linear relationship between participant ratings and observed Hedge's g scores; 95% CI corresponds to the estimated value of B1.")
# delete vestigial
rm(in.s, on.s, v.s, p.s,
m.s1, m.s2,
m.sens, m.sens.student, m.sens.online, m.sens.pay)
# Define publication bias analysis that
# 1. Mathur and VanderWeele 2020 sensitivity analyses
# 2. Fits three-level precision-effect test
# 3a. Aggregates dependent effect sizes (with given rho value)
# 3b. Aggregated precision-effect test
# 3b. Fits Vevea and Hedges (1995) Weight-Function Model w/ aggregated effects
# 4a. Fit funnel plot
# 4b. Fit funnel plot w/ aggregated dependencies
# 5. Organizes results into list
##########################
PubBias = function(rho.val = .5){
# 1. sensitivity analyses
########################
sens <- pubbias_meta(yi = DF.es$es,
vi = DF.es$es.var,
cluster = DF.es$id.study,
selection_ratio = 10000000,
model_type = "robust",
favor_positive = T)
# you can run the code below to see how nonsensicle it is to look at disfavor bias
# pubbias_meta(yi = DF.es$es,
#              vi = DF.es$es.var,
#              cluster = DF.es$id.study,
#              selection_ratio = 10000000,
#              model_type = "robust",
#              favor_positive = F)
# 2a. three-level precision-effect test
########################
pe.3l <- rma.mv(yi = es,
V = es.var,
mods = ~ sqrt(es.var),
data = DF.es,
random = ~ 1 | id.study / id.es)
# 2b. cluster robust three-level precision-effect test
########################
pe.3l.r <- rma.mv(yi = es,
V = es.var,
mods = ~ sqrt(es.var),
data = DF.es,
random = ~ 1 | id.study / id.es) %>%
robust(x = .,
cluster = id.study,
clubSandwich = T)
# 3a. aggregate dependent effect sizes
########################
DF.agg <- DF.es %>%
# convert to an 'escalc' object so function can run
escalc(yi = es,
vi = es.var,
data = DF.es,
measure = "SMD") %>%
# delete vestigial: es is now yi; es.var is now vi
select(-c(es, es.var)) %>%
# aggregate dependencies
aggregate(x = .,
cluster = id.study,
rho = rho.val)
# 3b. aggregated precision-effect test
########################
pe.a <- rma.uni(yi = yi,
vi = vi,
mods = ~ sqrt(vi),
data = DF.agg,
method = "REML")
# temp code: aggregated precision-effect test
########################
rma.uni(yi = yi,
vi = vi,
mods = ~ sqrt(vi),
data = DF.agg %>% filter(id.study != 30,
id.study != 55),
method = "REML")
# 3c. Weight-function model
########################
weight.funct <- weightfunct(effect = DF.agg$yi,
v = DF.agg$vi,
mods = NULL,
weights= NULL,
fe = FALSE,
table = TRUE,
pval = NULL)
# 4a. funnel plot
########################
par(mfrow=c(1,2))
rma.uni(yi = es,
vi = es.var,
data = DF.es,
method = "REML") %>%
metafor::funnel(hlines = "lightgray",
xlab = "Cohen's standardized d")
# 4b. funnel plot w/ aggregated dependencies
########################
rma.uni(yi = yi,
vi = vi,
data = DF.agg,
method = "REML") %>%
metafor::funnel(hlines = "lightgray",
xlab = "Cohen's standardized d (aggregated)")
# save funnel plot as object
funnel.plot <- recordPlot()
# clear R environment
plot.new()
# 5. Organize results in list
########################
list(sens = sens,
pe.3l = pe.3l,
pe.3l.r = pe.3l.r,
DF.agg = DF.agg,
pe.a = pe.a,
weight.funct = weight.funct,
funnel = funnel.plot) %>%
return()
}
# for range of rho values, run publication bias analyses
rho.l = seq(from = .1,
to = .9,
by = .2)
pub.r <- lapply(X = rho.l,
FUN = PubBias)
names(pub.r) = paste0("rho_", rho.l) #  name list
# delete vestigial
rm(rho.l, PubBias)
# look at sensitivity analyses
## general story: often, but not always, find evidence of reverse publication bias (preference for negative effects)
# lapply(pub.r, function(x){x[["pe.a"]]})
# lapply(pub.r, function(x){x[["peese"]]})
# lapply(pub.r, function(x){x[["weight.funct"]]})
# lapply(pub.r, function(x){x[["funnel"]]})
# plot funnels
# overall %>%
#   metafor::funnel(x = .,
#                   hlines = "lightgray",
#                   xlab = "Cohen's standardized d")
#
# pub.r$rho_0.5$pe.3l$b[2]
#
# pub.r$rho_0.5$weight.funct %>% View()
lapply(pub.r, function(x){x[["pe.a"]]})
lapply(pub.r, function(x){x[["peese"]]})
lapply(pub.r, function(x){x[["weight.funct"]]})
lapply(pub.r, function(x){x[["funnel"]]})
