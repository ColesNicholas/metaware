return(es.var)
}
# Chunk 15: w: call functions to calculate d
for (i in 1:nrow(DF)) {
if (DF$design[i] == "within"){
# call EsWitnMean on cases with within-subject designs and *means*
if(DF$es.calc[i] == "m_sd") {
DF$es[i] <- EsWitnMean(m.1 = DF$m.1[i],
sd.1 = DF$sd.1[i],
m.2 = DF$m.2[i],
sd.2 = DF$sd.2[i],
corr = corr)
}
# call EsWitnTval on cases with within-subject designs and *t-values*
if (DF$es.calc[i] == "t") {
DF$es[i] <- EsWitnTval(n.1 = DF$n.1[i],
tval = DF$tval[i],
corr = corr)
}
# call EsWitnFval on cases with within-subject designs and *F-values*
if (DF$es.calc[i] == "f") {
DF$es[i] <- EsWitnFval(n.1 = DF$n.1[i],
fval = DF$fval[i],
corr = corr)
}
# call EsVarWitn on cases with within subject designs
DF$es.var[i] <- EsVarWitn(n.1 = DF$n.1[i],
es = DF$es[i])
}
}
# Chunk 16: del var
# delete objects we no longer need
rm(corr, i,
EsBetwFval, EsBetwMean, EsBetwTval,
EsBetwPval, EsVarBetw, EsVarWitn,
EsWitnFval, EsWitnMean, EsWitnTval,
EsBetwCount, EsVarBetwCount)
# Chunk 17: specify es direction
DF <- DF %>%
# specify direction of the effect size
rowwise() %>%
mutate(es = if_else(condition = direction == "positive",
true = abs(es),
false = abs(es) * -1)
) %>%
ungroup()
# Chunk 18
DF <- DF %>%
rowwise() %>%
mutate(j = 1 - (3 / ((4 * (n.1  + n.2 - 2)) - 1)),
es = es * j,
es.var = es.var * (j^2)) %>%
ungroup() %>%
select(-j)
# Chunk 19
qual <-
# open data
read_xlsx(path = "data/metaware_EsData_raw.xlsx",
sheet = "quality.coding",
na = c("NA")) %>%
# calculate scales
rowwise() %>%
mutate(report = mean(c(report_1, report_2,
report_3, report_4,
report_6, report_7,
report_10),
na.rm = T),
external = external_12,
internal = mean(c(internal_14, internal_15,
internal_16, internal_18),
na.rm = T),
id.study = id) %>%
ungroup() %>%
# select relevant variables
select(id.study, report, external, internal)
# merge data
DF <- left_join(x = DF,
y = qual,
by = "id.study")
rm(qual)
# Chunk 20
DF <- DF %>%
# where appropriate, convert variables to factors
mutate(across(.cols = c(id.study, id.es, published, student,
paid, online, ref.type,
ref.r),
.fns = as.factor)
) %>%
# remove unnecessary columns
select(-c(es.calc : pval))
# Chunk 21
# import data
DF.surv <- read_csv(file = "data/metaware_SurvData_raw.csv") %>%
# remove unnecessary variables
select(-c(StartDate : UserLanguage),
-c(hap1_bl1_hap : survey_order),
-contains("Click"),
-contains("Submit"),
-contains("Count")) %>%
# remove row containing ImportId
filter(!grepl("ImportId", `1_awr`)) %>%
# assign participant ids
mutate(ss = 1 : nrow(.),
ss = as.character(ss)) %>%
# select columns containing information from the vignettes
select(`1_awr` : `119_opp`, ss) %>%
# extract vignette identifier from the first row of data
# note: I warned you the data structure is awkward
mutate_all(~if_else(condition = grepl("#", .),
true = substr(x = .,
start = 2,
stop = 9),
false = .))
# append first row (containing vignette identifiers) to the column name
## append name
colnames(DF.surv) <- paste(sep = "##",
colnames(DF.surv),
as.character(unlist(DF.surv[1, ]))
)
## remove the first row
### now that the vignette identifier has been added to the column name, we don't need this row anymore
DF.surv <- DF.surv[-1, ]
## fix ss (subject identifier) variable naming
DF.surv <- DF.surv %>%
rename("ss" = "ss##1")
# pivot data so that there is one row for each participants' rating of each vignette
DF.surv <- DF.surv %>%
# pivot longer
pivot_longer(cols = contains("##"),
names_to = c("var", "vig"),
names_sep = "##") %>%
# extract variable name
mutate(var = substr(x = var,
start = nchar(var) - 2,
stop = nchar(var))) %>%
# pivot wider
pivot_wider(names_from = var,
values_from = value) %>%
# convert columns to correct class
mutate_at(c("awr", "mot", "opp", "bel", "pre"),
as.numeric)
# Chunk 22
# create temporary dataset with only completed ratings
tmp.DF <- DF.surv %>%
filter(!is.na(mot),
!is.na(opp),
!is.na(bel),
!is.na(pre))
# mot icc: .23
mot.icc <- lmer(mot ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF) %>%
icc(by_group = T)
# opp icc: .21
opp.icc <- lmer(opp ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF) %>%
icc(by_group = T)
# bel icc: .14
bel.icc <- lmer(bel ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF)  %>%
icc(by_group = T)
# pre icc: .21
pre.icc <- lmer(pre ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF)  %>%
icc(by_group = T)
# export
list(mot = mot.icc,
opp = opp.icc,
bel = bel.icc,
pre = pre.icc) %>%
saveRDS(.,
"output/vig.surv1.rel.rds")
rm(tmp.DF, mot.icc, opp.icc, pre.icc, bel.icc)
# Chunk 23
# import data
DF.surv2 <- read_csv(file = "data/metaware_SurvData2_raw.csv") %>%
# remove unnecessary variables
select(-c(StartDate : UserLanguage,
vig_assign,
`indiv_desc_tme_First Click` : SESSION_ID),
-contains("Click"),
-contains("Submit"),
-contains("Count")) %>%
# remove row containing ImportId
filter(!grepl("ImportId", `1_awr`)) %>%
# assign participant ids
mutate(ss = 1 : nrow(.),
ss = as.character(ss)) %>%
# select columns containing information from the vignettes
select(`1_awr` : `121_opp`, ss) %>%
# extract vignette identifier from the first row of data
# note: I warned you the data structure is awkward
mutate_all(~if_else(condition = grepl("#", .),
true = substr(x = .,
start = 2,
stop = 9),
false = .))
# append first row (containing vignette identifiers) to the column name
## append name
colnames(DF.surv2) <- paste(sep = "##",
colnames(DF.surv2),
as.character(unlist(DF.surv2[1, ]))
)
## remove the first row
### now that the vignette identifier has been added to the column name, we don't need this row anymore
DF.surv2 <- DF.surv2[-1, ]
## fix ss (subject identifier) variable naming
DF.surv2 <- DF.surv2 %>%
rename("ss" = "ss##1")
# pivot data so that there is one row for each participants' rating of each vignette
DF.surv2 <- DF.surv2 %>%
# pivot longer
pivot_longer(cols = contains("##"),
names_to = c("var", "vig"),
names_sep = "##") %>%
# extract variable name
mutate(var = substr(x = var,
start = nchar(var) - 2,
stop = nchar(var))) %>%
# pivot wider
pivot_wider(names_from = var,
values_from = value) %>%
# convert columns to correct class
mutate_at(c("awr", "mot", "opp", "bel", "pre"),
as.numeric) %>%
# assign subject identifiers that are distinct from DF.surv
mutate(ss = as.numeric(ss) + max(as.numeric(DF.surv$ss)),
ss = as.character(ss))
# Chunk 24
DF.surv <- rbind(DF.surv, DF.surv2)
rm(DF.surv2)
# Chunk 25
# create temporary dataset with only completed ratings
tmp.DF <- DF.surv %>%
filter(!is.na(mot),
!is.na(opp),
!is.na(bel),
!is.na(pre))
# mot icc: .23
mot.icc <- lmer(mot ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF) %>%
icc(by_group = T)
# opp icc: .23
opp.icc <- lmer(opp ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF) %>%
icc(by_group = T)
# bel icc: .16
bel.icc <- lmer(bel ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF)  %>%
icc(by_group = T)
# pre icc: .22
pre.icc <- lmer(pre ~ 1 + (1 | ss) + (1 | vig),
data = tmp.DF)  %>%
icc(by_group = T)
# export
list(mot = mot.icc,
opp = opp.icc,
bel = bel.icc,
pre = pre.icc) %>%
saveRDS(.,
"output/vig.survfull.rel.rds")
rm(tmp.DF, mot.icc, opp.icc, pre.icc, bel.icc)
# Chunk 26
DF.surv <- DF.surv %>%
# identify whether the researcher hypothesis was pos, neg, or nil
mutate(dem = substr(x = vig,
start = 4,
stop = 4))
## set att.chk to 0 (failed attention check) by default
DF.surv$att.chk = 0
## set att.chk to 1 when hypothesis is correctly identified
### positive hypothesis (dem == p)
DF.surv[DF.surv$dem == "p" &
!is.na(DF.surv$awr) &
DF.surv$awr == 1, ]$att.chk = 1
### negative hypothesis (dem == n)
DF.surv[DF.surv$dem == "n" &
!is.na(DF.surv$awr) &
DF.surv$awr == 2, ]$att.chk = 1
### nil hypothesis (dem == z)
DF.surv[DF.surv$dem == "z" &
!is.na(DF.surv$awr) &
DF.surv$awr == 3, ]$att.chk = 1
## if participants did not respond to the attention check item, set the att.chk variable to NA
DF.surv[is.na(DF.surv$awr), ]$att.chk = NA
## manually fix 28_p_dis vignette attention check
## there were some oddities in how we created this vignette--but the correct hypothesis would be 2 (not 1)
DF.surv[DF.surv$vig == "28_p_dis" &
!is.na(DF.surv$awr) &
DF.surv$awr == 2, ]$att.chk = 1
# Chunk 28
DF.surv <- DF.surv %>%
filter(att.chk == 1)
# Chunk 29
surv.sum <- DF.surv %>%
group_by(vig) %>%
summarise(m.mot = mean(mot, na.rm = T),
m.opp = mean(opp, na.rm = T),
m.bel = mean(bel, na.rm = T),
m.pre = mean(pre, na.rm = T)
) %>%
ungroup()
# remove old survey dataframe (not needed anymore)
rm(DF.surv)
# Chunk 30
# connect summary data to effect size dataframe
DF <- DF %>%
# join vig.1 data
## rename vig.1 to vig to enable join
rename(vig = vig.1) %>%
## connect summary data to vig.1
left_join(x = .,
y = surv.sum,
by = "vig") %>%
## rename vig.1 summary columns
rename(v1.mot = m.mot,
v1.opp = m.opp,
v1.bel = m.bel,
v1.pre = m.pre) %>%
# join vig.2 data
## rename vig.2 to vig to prep for join
rename(vig.1 = vig,
vig = vig.2) %>%
## connect summary data to vig.2
left_join(x = .,
y = surv.sum,
by = "vig") %>%
## rename vig.2 summary columns
rename(v2.mot = m.mot,
v2.opp = m.opp,
v2.bel = m.bel,
v2.pre = m.pre) %>%
# sum motivation, opportunity, belief, and prediction scores
rowwise() %>%
mutate(mot = sum(c(v1.mot, v2.mot),
na.rm = T),
opp = sum(c(v1.opp, v2.opp),
na.rm = T),
bel = sum(c(v1.bel, v2.bel),
na.rm = T),
pre = sum(c(v1.pre, v2.pre),
na.rm = T)) %>%
ungroup()
# set motivation, opportunity, belief, and prediction scores blank for id 18
# we did not create vignettes for id 18 because it was a *massive* outlier that we removed from all analyses
DF[DF$id.study == 18, ]$mot = NA
DF[DF$id.study == 18, ]$opp = NA
DF[DF$id.study == 18, ]$bel = NA
DF[DF$id.study == 18, ]$pre = NA
# organize ordering of variables
DF <- DF %>%
select(id.study, id.es,
citation : ref.r,
es, es.var,
mot : pre,
report : internal)
# Chunk 31
# import data
DF.surv2 <-
read_csv(file = "data/metaware_SurvData_raw.csv")
# remove rows containing unnecessary variable details
DF.surv2 <- DF.surv2[-(1 : 2), ]
# hand recode gender
## list as unknown if they did not answer (or said they'd prefer not to answer)
DF.surv2[is.na(DF.surv2$indiv_gend_var), ]$indiv_gend_var = "unknown"
DF.surv2[DF.surv2$indiv_gend_var == "7", ]$indiv_gend_var = "unknown"
## recode rest
DF.surv2[DF.surv2$indiv_gend_var == "1", ]$indiv_gend_var = "female"
DF.surv2[DF.surv2$indiv_gend_var == "2", ]$indiv_gend_var = "male"
DF.surv2[DF.surv2$indiv_gend_var == "3", ]$indiv_gend_var = "trans_female"
DF.surv2[DF.surv2$indiv_gend_var == "4", ]$indiv_gend_var = "trans_male"
DF.surv2[DF.surv2$indiv_gend_var == "5", ]$indiv_gend_var = "gender_nonconforming"
# hand recode ethnicity
DF.surv2[is.na(DF.surv2$ethnicity), ]$ethnicity = "unknown"
DF.surv2[DF.surv2$ethnicity == "1", ]$ethnicity = "white_caucasian"
DF.surv2[DF.surv2$ethnicity == "2", ]$ethnicity = "black_african_american"
DF.surv2[DF.surv2$ethnicity == "3", ]$ethnicity = "american_indian"
DF.surv2[DF.surv2$ethnicity == "4", ]$ethnicity = "asian"
DF.surv2[DF.surv2$ethnicity == "5", ]$ethnicity = "native_pacific_islander"
DF.surv2[DF.surv2$ethnicity == "6", ]$ethnicity = "native_pacific_islander"
DF.surv2[DF.surv2$ethnicity == "6" |
DF.surv2$ethnicity == "1,6" |
DF.surv2$ethnicity == "1,2" |
DF.surv2$ethnicity == "1,4" |
DF.surv2$ethnicity == "2,6" |
DF.surv2$ethnicity == "7" |
DF.surv2$ethnicity == "1,3", ]$ethnicity = "other"
# process data
DF.surv2 <- DF.surv2 %>%
# identify relevant variables
select(
# block 1 happy pose emotion reports
hap1_bl1_hap : hap1_bl1_enj,
# block 1 neutral pose emotion reports
neu1_bl1_hap : neu1_bl1_enj,
# block 2 happy pose emotion reports
hap2_bl2_hap : hap2_bl2_enj,
# block 2 neutral pose emotion reports
neu2_bl2_hap : neu2_bl2_enj,
# motivation, prediction, belief, and opportunity scores
mot : opp, mot_gen,
# manipulation check items (awareness and attention checks)
hap1_bl1_att, hap2_bl2_att, neu1_bl1_att, neu2_bl2_att,
awr,
# condition and individual difference items
demand,
indiv_gend_var, indiv_agee_var, ethnicity,
# relevant vignette data
`46_awr` : `46_opp`,
`47_awr` : `47_opp`) %>%
# rename vignette variables
rename(pos_awr = `46_awr`,
pos_mot = `46_mot`,
pos_pre = `46_pre`,
pos_bel = `46_bel`,
pos_opp = `46_opp`,
nil_awr = `47_awr`,
nil_mot = `47_mot`,
nil_pre = `47_pre`,
nil_bel = `47_bel`,
nil_opp = `47_opp`) %>%
# add subid variable
mutate(sub = factor(1 : nrow(.))) %>%
# identify whether attention checks were all passed
mutate(att.chk =
if_else(condition =
hap1_bl1_att == "5" &
neu1_bl1_att == "5" &
hap2_bl2_att == "5" &
neu2_bl2_att == "5",
true = 1,
false = 0)
) %>%
# identify whether participants correctly identified the hypothesis
mutate(manip.chk =
if_else(condition =
demand == "pos" & awr == 1,
true = 1,
false =
if_else(condition =
demand == "nil" & awr == 2,
true = 1,
false = 0))) %>%
# create separate rows for each trial
# 1. Gather emotion reports into a single column
gather(key = "dv",
value = "value",
hap1_bl1_hap : neu2_bl2_enj) %>%
# 2. Create separate variables that identify the trial and outcome using "_..._ naming convention separator
separate(col = "dv",
into = c("trial", "outcome"),
sep = "_..._") %>%
# 3. Spread outcomes into individual rows
pivot_wider(names_from = "outcome",
values_from = "value") %>%
# fix variable types
mutate_at(.vars = c("mot", "pre", "bel", "opp",
"mot_gen", "indiv_agee_var",
"hap", "sat", "enj",
"pos_awr", "pos_mot",
"pos_pre", "pos_bel",
"pos_opp",
"nil_awr", "nil_mot",
"nil_pre", "nil_bel",
"nil_opp"),
.funs = as.numeric) %>%
mutate_at(.vars = c("demand", "indiv_gend_var",
"ethnicity", "sub"),
.funs = as.factor) %>%
# Calculate self-reported happiness scores
rowwise() %>%
mutate(happy = mean(c(hap, sat, enj))) %>%
ungroup() %>%
# identify block number
mutate(block.num = if_else(condition = trial == "hap1" |
trial == "neu1",
true = 1,
false = 2),
block.num = factor(block.num)) %>%
# create new trial variable that remove redundant information about block
mutate(trial = substr(x = trial,
start = 1,
stop = 3),
trial = factor(trial)) %>%
# organize dataframe
arrange(sub, block.num, trial) %>%
select(sub, demand, trial, block.num, happy,
att.chk, manip.chk,
mot : mot_gen,
indiv_gend_var : ethnicity) %>%
# recode (flip) motivation for the nil hypothesis condition
rowwise() %>%
mutate(mot = if_else(demand == "nil",
mot * (-1),
mot)) %>%
ungroup()
# center motivation, opportunity, and belief scores
DF.surv2$mot.c = scale(DF.surv2$mot,
scale = F) %>% as.numeric()
DF.surv2$opp.c = scale(DF.surv2$opp,
scale = F) %>% as.numeric()
DF.surv2$bel.c = scale(DF.surv2$bel,
scale = F) %>% as.numeric()
# Chunk 32
if(!exists("sens")){
write.csv(DF,
"data/metaware_meta_clean.csv",
row.names = F)
}
# Chunk 33
write.csv(DF.surv2,
"data/metaware_replication_clean.csv",
row.names = F)
