ub = es + (se * 1.96),
ub = round(ub, 2),
lb = es - (se * 1.96),
lb = round(lb, 2),
es = round(es, 2)) %>%
ungroup() %>%
arrange(es, id.study)
ggplot(data= tmp,
aes(y = rev(1: nrow(tmp)),
x = es,
xmin = lb,
xmax = ub)) +
# create line at 0
geom_vline(xintercept = 0,
color = "black",
linetype = "dashed",
alpha = .5) +
# add points and error bars
geom_point(shape = "diamond",
size = 2,
colour = '#FFC000') +
geom_errorbarh(height = .5,
colour = '#FFC000') +
# add citation label
geom_text(aes(label = citation),
x = -2.7,
hjust = 0,
size = 1.3) +
# add CI label
geom_text(aes(label = paste0(es,
" [", lb, ", ", ub, "]")),
x = 3.9,
size = 1.3,
hjust = 1) +
# remove y-axis
theme(axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
axis.line.y = element_blank()) +
# increase plotting area
scale_x_continuous(limits = c(-2.7, 4),
breaks = seq(from = -2, to = 3.5, by = .5),
expand = c(.01, .01)) +
scale_y_continuous(expand = c(.01, .01))
# Chunk 1: setup
# load packages writing and data processing packages
library("papaja")
library("tidyverse")
library("readxl")
library("cowplot")
# load meta-analyses packages
library("metafor")
library("weightr")
library("PublicationBias")
# load mixed-effect regression packages
library(lme4)
library(lmerTest)
library(emmeans)
# identify refs
r_refs("r-references.bib")
# set theme
theme_set(theme_classic())
# Chunk 2: framework
knitr::include_graphics("images/metaware_framework.png")
# Chunk 3: literature search
# open and process literature search data
DF.s <-
# open data
read_xlsx(path = "data/metaware_EsData_raw.xlsx",
sheet = "records.screening") %>%
# identify unpublished dissertations by identifying links that contain the word 'dissertation'
mutate(dissertation =
if_else(condition = grepl("dissertation", link),
true = 1,
false = 0)
)
# calculate number of records from PsycInfo by removing all records with no known database (i.e., ones that were personally found)
r.pi <- DF.s %>%
filter(!is.na(Database)) %>%
nrow()
# calculate number of unpublished records (i.e., dissertations)
r.unp <- DF.s %>%
filter(dissertation == 1) %>%
nrow()
# Chunk 4: final.df
# open clean effect size data
DF.es <-
read_csv(file = "data/metaware_data_clean.csv")
# identify total number of studies (denoted by id.study column)
num.s <- DF.es$id.study %>%
unique() %>%
length()
# identify total number of papers (denoted by name column)
num.p <- DF.es$name %>%
unique() %>%
length()
# for the known outlier (id = 18), give an example of the largest effect size
outlier.es <- DF.es %>%
filter(id.study == 18) %>%
summarise(max.es = min(es)) %>% #  using min because largest value is neg
round(2)
# Chunk 5: clean.env.1
# remove outlier and re-initialize id factors
DF.es <- DF.es %>%
filter(id.study != 18) %>%
mutate(id.study = factor(id.study),
id.es = factor(id.es))
# clean environment
rm(DF.s, r.pi, r.unp, num.s, num.p, outlier.es)
# Chunk 6: corr.sens
# examine how assumed repeated measures correlation impacts general pattern of results
# get list of sensitivity dataframes
sens.df.list <- list.files(path = "./data/r_sensitivity")
# (1) open dataframe, (2) compute intercept-only model, (3) extract overall es
sens.res <-
sapply(X = sens.df.list,
FUN = function(i){
# open data
df <- read.csv(paste0("data/r_sensitivity/",
i)
)
# fit model
m <- rma.mv(yi = es,
V = es.var,
data = DF.es,
random = ~ 1 | id.study / id.es)
# return overall es as a number
m$b %>%
as.numeric() %>%
return()
}
)
# compute range of es values
sens.range <- max(sens.res) - min(sens.res)
# delete vestigial
rm(sens.df.list, sens.res)
# Chunk 7: mult.eff
# calculate percentage of studies with multiple effect sizes
mult.eff.per <- DF.es %>%
# identify number of effect sizes for each study (id)
group_by(id.study) %>%
count() %>%
# code whether each study has more than one effect size
mutate(dep = if_else(condition = n > 1,
true = 1,
false = 0)
) %>%
# calculate proportion of studies with more than one effect size
ungroup() %>%
summarise(mult.eff = mean(dep)) %>%
# export as percentage
as.numeric() %>%
round(digits = 2) * 100
# Chunk 8: clean.env.2
# delete vestigial
rm(mult.eff.per, vig.n, survey.n, sens.range)
# Chunk 9: overall
# estimate overall effect size
overall <-
rma.mv(yi = es,
V = es.var,
data = DF.es,
random = ~ 1 | id.study / id.es)
# overall <-
#   rma.uni(yi = es,
#           vi = es.var,
#           data = DF.es,
#           method = "REML") %>%
#   robust(cluster = DF.es$id)
# Chunk 10: forest
tmp <- DF.es %>%
rowwise() %>%
mutate(se = sqrt(es.var),
ub = es + (se * 1.96),
ub = round(ub, 2),
lb = es - (se * 1.96),
lb = round(lb, 2),
es = round(es, 2)) %>%
ungroup() %>%
arrange(es, id.study)
ggplot(data= tmp,
aes(y = rev(1: nrow(tmp)),
x = es,
xmin = lb,
xmax = ub)) +
# create line at 0
geom_vline(xintercept = 0,
color = "black",
linetype = "dashed",
alpha = .5) +
# add points and error bars
geom_point(shape = "diamond",
size = 2,
colour = '#FFC000') +
geom_errorbarh(height = .5,
colour = '#FFC000') +
# add citation label
geom_text(aes(label = citation),
x = -2.7,
hjust = 0,
size = 1.3) +
# add CI label
geom_text(aes(label = paste0(es,
" [", lb, ", ", ub, "]")),
x = 3.9,
size = 1.3,
hjust = 1) +
# remove y-axis
theme(axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
axis.line.y = element_blank()) +
# increase plotting area
scale_x_continuous(limits = c(-2.7, 4),
breaks = seq(from = -2, to = 3.5, by = .5),
expand = c(.01, .01)) +
scale_y_continuous(expand = c(.01, .01))
# Chunk 11: mod
# create moderator analysis function
ModAnalysis = function(m, df = DF.es) {
# set dataset
df <- df
# moderator analysis
mod.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ ", m)),
test= "t")
sub.m <- rma.mv(yi = es,
V = es.var,
data = df,
random = ~ 1 | id.study / id.es,
mods = as.formula(paste0("~ 0 + ", m)),
test= "t")
# return results as list
return(list(mod = mod.m,
sub = sub.m))
}
# conduct moderator and subgroup analyses for moderators assessed with full dataset
mod.l <- c("student", "paid", "online",
"design", "ref.r", "published",
"year")
mod.r <-
sapply(X = mod.l,
simplify = F,
FUN = ModAnalysis)
rm(mod.l)
# test ref.type moderator in scenarios where there is a control comparison (i.e., ref.r == single)
mod.r[["ref.type"]] <-
ModAnalysis(m = "ref.type",
df = DF.es[DF.es$ref.r == "single", ])
# add motivation, opportunity, belief, and prediction moderators
## Note: comparisons with nil-demand conditions are excluded
mod.r.2 <-
sapply(X = c("mot", "opp", "bel", "pre"),
simplify = F,
FUN = ModAnalysis,
df = DF.es %>%
filter(ref.type != "cvz" &
ref.type != "pvz"))
## combine results
mod.r = c(mod.r, mod.r.2)
# delete vestigial
rm(mod.r.2)
# Chunk 12: pub.bias
##########################
# Define publication bias analysis that
# 1. Mathur and VanderWeele 2020 sensitivity analyses
# 2. Fits three-level precision-effect test
# 3a. Aggregates dependent effect sizes (with given rho value)
# 3b. Aggregated precision-effect test
# 3b. Fits Vevea and Hedges (1995) Weight-Function Model w/ aggregated effects
# 4a. Fit funnel plot
# 4b. Fit funnel plot w/ aggregated dependencies
# 5. Organizes results into list
##########################
PubBias = function(rho.val = .5){
# 1. sensitivity analyses
########################
sens <- corrected_meta(yi = DF.es$es,
vi = DF.es$es.var,
eta = 49,
clustervar = DF.es$id.study,
model = "robust",
favor.positive = T)
# 2. three-level precision-effect test
########################
pe.3l <- rma.mv(yi = es,
V = es.var,
mods = ~ sqrt(es.var),
data = DF.es,
random = ~ 1 | id.study / id.es)
# 3a. aggregate dependent effect sizes
########################
DF.agg <- DF.es %>%
# convert to an 'escalc' object so function can run
escalc(yi = es,
vi = es.var,
data = DF.es,
measure = "SMD") %>%
# delete vestigial: es is now yi; es.var is now vi
select(-c(es, es.var)) %>%
# aggregate dependencies
aggregate(x = .,
cluster = id.study,
rho = rho.val)
# 3b. aggregated precision-effect test
########################
pe.a <- rma.uni(yi = yi,
vi = vi,
mods = ~ sqrt(vi),
data = DF.agg,
method = "REML")
# 3c. Weight-function model
########################
weight.funct <- weightfunct(effect = DF.agg$yi,
v = DF.agg$vi,
mods = NULL,
weights= NULL,
fe = FALSE,
table = TRUE,
pval = NULL)
# 4a. funnel plot
########################
par(mfrow=c(1,2))
rma.uni(yi = es,
vi = es.var,
data = DF.es,
method = "REML") %>%
metafor::funnel(hlines = "lightgray",
xlab = "Cohen's standardized d")
# 4b. funnel plot w/ aggregated dependencies
########################
rma.uni(yi = yi,
vi = vi,
data = DF.agg,
method = "REML") %>%
metafor::funnel(hlines = "lightgray",
xlab = "Cohen's standardized d (aggregated)")
# save funnel plot as object
funnel.plot <- recordPlot()
# clear R environment
plot.new()
# 5. Organize results in list
########################
list(sens = sens,
pe.3l = pe.3l,
DF.agg = DF.agg,
pe.a = pe.a,
weight.funct = weight.funct,
funnel = funnel.plot) %>%
return()
}
# for range of rho values, run publication bias analyses
rho.l = seq(from = .1,
to = .9,
by = .2)
pub.r <- lapply(X = rho.l,
FUN = PubBias)
names(pub.r) = paste0("rho_", rho.l) #  name list
# delete vestigial
rm(rho.l, PubBias)
# look at sensitivity analyses
## general story: often, but not always, find evidence of reverse publication bias (preference for negative effects)
# lapply(pub.r, function(x){x[["pet"]]})
# lapply(pub.r, function(x){x[["peese"]]})
# lapply(pub.r, function(x){x[["weight.funct"]]})
# lapply(pub.r, function(x){x[["funnel"]]})
# plot funnels
# overall %>%
#   metafor::funnel(x = .,
#                   hlines = "lightgray",
#                   xlab = "Cohen's standardized d")
#
# pub.r$rho_0.5$pe.3l$b[2]
#
# pub.r$rho_0.5$weight.funct %>% View()
# Chunk 13: funnel2
##########
# Funnel plot with non-aggregated dependencies
##########
# create a temporary dataset with standard error (se) values
tmp <- DF.es %>%
rowwise() %>%
mutate(se = sqrt(es.var)) %>%
ungroup()
# create temporary sequence of ses
se.seq = seq(0, max(tmp$se),
length.out = nrow(DF.es))
ll95 = overall$b[1] - (1.96 * se.seq)
ul95 = overall$b[1] + (1.96 * se.seq)
# create coordinates for polygon
t.coord <- rbind(cbind(x = overall$b[1],
y = 0),
cbind(x = min(ll95),
y = max(tmp$se)),
cbind(x = max(ul95),
y = max(tmp$se))
) %>%
as.data.frame()
# plot
a <- ggplot(data = tmp,
aes(x = es,
y = se)) +
geom_polygon(data = t.coord,
aes(x = x,
y = y),
fill = "#3366FF",
alpha = .1) +
geom_jitter(alpha = .8,
fill = "dark grey",
color = "dark grey") +
scale_y_reverse() +
geom_vline(xintercept = overall$b[1],
linetype = "dotted") +
labs(x = "Cohen's d",
y = "Standard error")
# delete vestigial
rm(tmp, ll95, ul95, se.seq, t.coord)
##########
# Funnel plot with aggregated dependencies
##########
# create a temporary dataset with standard error (se) values
tmp <- pub.r$rho_0.5$DF.agg %>%
rowwise() %>%
mutate(es = yi,
se = sqrt(vi)) %>%
ungroup()
# calculate overall effect size
tmp.meta <- rma.uni(yi = yi,
vi = vi,
data = tmp,
method = "REML")
# create temporary sequence of ses
se.seq = seq(0, max(tmp$se),
length.out = nrow(tmp))
ll95 = tmp.meta$b[1] - (1.96 * se.seq)
ul95 = tmp.meta$b[1] + (1.96 * se.seq)
# create coordinates for polygon
t.coord <- rbind(cbind(x = tmp.meta$b[1],
y = 0),
cbind(x = min(ll95),
y = max(tmp$se)),
cbind(x = max(ul95),
y = max(tmp$se))
) %>%
as.data.frame()
b <- ggplot(data = tmp,
aes(x = es,
y = se)) +
geom_polygon(data = t.coord,
aes(x = x,
y = y),
fill = "#3366FF",
alpha = .1) +
geom_jitter(alpha = .8,
fill = "dark grey",
color = "dark grey") +
scale_y_reverse() +
geom_vline(xintercept = tmp.meta$b[1],
linetype = "dotted") +
labs(x = "Cohen's d",
y = "Standard error")
# delete vestigial
rm(tmp, ll95, ul95, se.seq, t.coord)
##########
# Plot funnels next to each other plot with aggregated dependencies
##########
plot_grid(a, b,
labels = c("A", "B"))
rm(a, b)
?rnorm
tmp <- rnorm(n = 10,000,
mean = overall$b,
overall$sigma2[1])
tmp <- rnorm(n = 10,000,
mean = overall$b,
sd = overall$sigma2[1])
overall$sigma2[1]
overall$b
as.numeric(overall$b)
rnorm(n = 10,000,
mean = as.numeric(overall$b),
sd = overall$sigma2[1])
tmp <- rnorm(n = 10000,
mean = as.numeric(overall$b),
sd = overall$sigma2[1])
hist(tmp)
hist(tmp)
?pnorm
tmp <- rnorm(n = 10000,
mean = overall$b,
sd = sqrt(overall$sigma2[1])
)
hist(tmp)
overall$sigma2[1]
overall$sigma2[1] %>% sqrt()
?sqrt
?pnorm
pnorm(q = 0,
mean = overall$b,
sd = sqrt(overall$sigma2[1]),
)
pnorm(q = 0,
mean = overall$b,
sd = sqrt(overall$sigma2[1]),
lower.tail = F)
pnorm(q = 0,
mean = overall$b,
sd = sqrt(overall$sigma2[1]),
)
