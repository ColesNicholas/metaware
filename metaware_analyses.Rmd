---
title: Data analysis for "A meta-analysis of the effects of demand characteristics in non-clinical research"
author: "Nicholas A. Coles and Morgan Wyatt"
editor_options: 
  chunk_output_type: console
---
The code was written in `r R.version$version.string` using R Markdown (http://rmarkdown.rstudio.com/).

# Section 1: Data Prep
```{r setup and load packages, include = FALSE}
# clean environment
rm(list = ls())

# load packages
ipak <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE)
    
    sapply(pkg, require, character.only = TRUE)
}

# call package function
packages <- c('metafor', 'tidyverse', 
              'readxl', 'robumeta')
ipak(packages)
rm(packages, ipak)

# turn scientific notation off
options(scipen = 999)
```

## Open and clean data
```{r open/clean data, message = FALSE, warning = FALSE}
# import data
DF <- read_xlsx(path = "metaware_data.xlsx",
                sheet = "coding",
                na = c("NA"))

# delete unnecessary variables
DF <- DF %>% 
  
  # remove reference columns
  select(-ends_with("ref")) %>% 
  
  # remove variables we won't include in any analyses
  select(-c(prop.woman : online, note))

# temporarily delete p-value caess
# DF <- DF %>% 
#   filter(es.calc != "pval")

# create blank columns for effect size and effect size variance
# Note: these pre-exisiting columns are necessary for the 
# Cohen's d functions (defined later) to work
DF$es <- NA
DF$es.var <- NA
```

Different formulas for within vs. between subjects designs

Different formulas based on what info we're working with

# Calculate Cohen's *d* and variance
## For between-subjects data
### Functions for calculating *d* 
#### When *M*'s and *SD*'s are provided
```{r define function EsBetwMean}
# formula: Cooper, Hedges, & Valentine, 2009; p. 226
EsBetwMean <- function(n.1, m.1, sd.1, 
                       n.2, m.2, sd.2){
    sd.within <- sqrt((((n.1 - 1) * (sd.1^2)) +
                       ((n.2 - 1) * (sd.2^2))) /
                        (n.1 + n.2 - 2));
    
    es <- (m.1 - m.2) / sd.within;
    return(es)
}
```

#### When t-values are provided
```{r define function EsBetwTval}
# formula: Cooper, Hedges, & Valentine, 2009; p. 228
EsBetwTval <- function(n.1, n.2, tval){
    es <- tval * sqrt((n.1 + n.2) / 
                      (n.1 * n.2));
    return(es)
}
```

#### When F-values are provided
```{r define function EsBetwFval}
# formula: Cooper, Hedges, & Valentine, 2009; p. 228
EsBetwFval <- function(n.1, n.2, fval){
  es <- sqrt((fval * (n.1 + n.2)) / 
             (n.1 * n.2)); 
    return(es)
  }
```

### Function for calculating variance of *d*
```{r define function EsVarBetw}
# formula: Cooper, Hedges, & Valentine, 2009; p. 228
EsVarBetw <- function(n.1, n.2, es){       
   es.var <- ((n.1 + n.2) / (n.1 * n.2)) +
             ((es^2) / (2 * (n.1 + n.2)));
   return(es.var)
}
```

### Call functions to calculate d and variance of *d*
```{r b: call functions to calculate d}
for (i in 1:nrow(DF)) {
  if (DF$design[i] == "between"){
    
    # call EsBetwMean on cases with between-subject designs and *means*
    if (DF$es.calc[i] == "m_sd") {
      DF$es[i] <- EsBetwMean(n.1 = DF$n.1[i],
                              m.1 = DF$m.1[i],
                              sd.1 = DF$sd.1[i],
                              n.2 = DF$n.2[i],
                              m.2 = DF$m.2[i],
                              sd.2 = DF$sd.2[i]) 
      } 
    # call EsBetwTval on cases with between-subject designs and *t-values*
    if (DF$es.calc[i] == "t") {
      DF$es[i] <- EsBetwTval (n.1 = DF$n.1[i],
                               n.2 = DF$n.2[i],
                               tval = DF$tval[i])
      }
    
    # call EsBetwFval on cases with between-subject designs and *F-values*
    if (DF$es.calc[i] == "f") {
      DF$es[i] <- EsBetwFval (n.1 = DF$n.1[i],
                               n.2 = DF$n.2[i],
                               fval = DF$fval[i])
    }
    
    # call EsVarBetw on cases with between subject designs
    DF$es.var[i] <- EsVarBetw(n.1 = DF$n.1[i],
                               n.2 = DF$n.2[i],
                               es = DF$es[i])
    }
}
```

## For within-subjects data
```{r assumed correlation}
# define assumed correlation (sensitivity analyses performed later)
corr <- .5
```

### Functions for calculating d
#### When M's and SD's are provided 
```{r EsWitnMean}
# formula: Cooper, Hedges, & Valentine, 2009; p. 229
# formula for imputing sd.diff:
# http://handbook.cochrane.org/chapter_16/16_4_6_1_mean_differences.htm
EsWitnMean <- function(m.1, sd.1, m.2, sd.2, corr){
  sd.diff <- sqrt((sd.1^2) + (sd.2^2) -
                  (2 * corr * sd.1 * sd.2));
        
  es <- ((m.1 - m.2) / sd.diff) * sqrt(2 * (1- corr));
  return(es)
}
```

#### When t-values are provided
```{r EsWitnTval}
# formula: Cooper, Hedges, & Valentine, 2009; p. 229
EsWitnTval <- function(n.1, tval, corr){
  es <- tval * sqrt((2 * (1 - corr)) / n.1);
  return(es)
}
```

#### When F-values are provided
```{r EsWitnFval}
# formula: Cooper, Hedges, & Valentine, 2009; p. 229
EsWitnFval <- function(n.1, fval, corr){
  es <- sqrt((2 * fval * (1- corr)) / n.1);
  return(es)
}
```

### Function for calculating variance of d
```{r EsVarWitn}
# formula: Cooper, Hedges, & Valentine, 2009; p. 229
EsVarWitn <- function(n.1, es){
  es.var <- ((1 / n.1) + 
             ((es^2) / (2 * n.1))) *
            2 * (1 - corr);
  return(es.var)
}
```

### Call functions to calculate d and variance of d
```{r w: call functions to calculate d}
for (i in 1:nrow(DF)) {
  if (DF$design[i] == "within"){
    
    # call EsWitnMean on cases with within-subject designs and *means*
    if(DF$es.calc[i] == "m_sd") {
      DF$es[i] <- EsWitnMean(m.1 = DF$m.1[i],
                             sd.1 = DF$sd.1[i],
                             m.2 = DF$m.2[i],
                             sd.2 = DF$sd.2[i],
                             corr = corr)
    }
    
    # call EsWitnTval on cases with within-subject designs and *t-values*
    if (DF$es.calc[i] == "t") {
      DF$es[i] <- EsWitnTval (n.1 = DF$n.1[i],
                              tval = DF$tval[i],
                              corr = corr)
  }  
    
    # call EsWitnFval on cases with within-subject designs and *F-values*
    if (DF$es.calc[i] == "f") {
      DF$es[i] <- EsWitnFval (n.1 = DF$n.1[i],
                              fval = DF$fval[i],
                              corr = corr)
    }
    
    # call EsVarWitn on cases with within subject designs
    DF$es.var[i] <- EsVarWitn (n.1 = DF$n.1[i],
                               es = DF$es[i])
    }
  }
  
```

```{r del var}
# delete unnecessary variables
rm(corr, i,
   EsBetwFval, EsBetwMean, EsBetwTval,
   EsVarBetw, EsVarWitn, 
   EsWitnFval, EsWitnMean, EsWitnTval)
```

## Specify direction
This direction of the effect was coded for in the raw database, and this code ensures that all effects are in the correct direction.
```{r specify es direction}
DF <- DF %>% 
  filter(id != 18) %>%  #  temporarily deleting because es' are outrageous
  
  # specify direction of the effect size
  rowwise() %>% 
  mutate(es = if_else(condition = direction == "positive",
                      true = abs(es),
                      false = abs(es) * -1)
         ) %>% 
  ungroup()
```

# Data analysis
Estimating overall effects
```{r}
# RE meta
results <- rma.uni(yi = es,
                   vi = es.var,
                   data = DF,
                   method = "REML")

funnel(results)

# rve meta
robu.results <- robu(formula = es ~ 1,
                     data = DF, 
                     studynum = id,
                     var.eff.size = es.var,
                     modelweights = "HEIR",
                     small = FALSE)

# agg meta
library(MAd)
DF.AGG <- agg(id = id,
              es = es,
              var = es.var,
              method = "BHHR",
              cor = .5, 
              data = DF)
  
## 1.1.b. run meta-analysis  
results.agg <- rma.uni(yi = es,
                       vi = var,
                       data = DF.AGG,
                       method = "REML")
funnel(results.agg)
```

Publication bias